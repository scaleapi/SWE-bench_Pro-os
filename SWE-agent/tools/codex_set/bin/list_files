#!/bin/bash
set -euo pipefail

# Parse arguments
PATH_ARG=""
DEPTH=1

while [[ $# -gt 0 ]]; do
    case "$1" in
        --path)
            PATH_ARG="$2"
            shift 2
            ;;
        --depth)
            DEPTH="$2"
            shift 2
            ;;
        *)
            echo "Error: Unknown argument $1"
            exit 1
            ;;
    esac
done

# Default to current directory if no path provided
if [[ -z "$PATH_ARG" ]]; then
    PATH_ARG="."
fi

# Check if path exists
if [[ ! -e "$PATH_ARG" ]]; then
    echo "Error: Path not found: $PATH_ARG"
    exit 1
fi

# Validate depth
if [[ ! "$DEPTH" =~ ^[0-9]+$ ]] || [[ "$DEPTH" -lt 1 ]]; then
    echo "Error: depth must be a positive integer (got: $DEPTH)"
    exit 1
fi

# Function to list files with indentation
list_with_depth() {
    local base_path="$1"
    local current_depth="$2"
    local max_depth="$3"
    local prefix="$4"

    # Get list of files and directories, sorted
    local items=()
    while IFS= read -r -d '' item; do
        items+=("$item")
    done < <(find "$base_path" -maxdepth 1 -mindepth 1 ! -name '.*' -print0 2>/dev/null | sort -z)

    local item_count=${#items[@]}
    local idx=0

    for item in "${items[@]}"; do
        idx=$((idx + 1))
        local basename=$(basename "$item")
        local is_last=false
        [[ $idx -eq $item_count ]] && is_last=true

        if [[ -d "$item" ]]; then
            if $is_last; then
                echo "${prefix}└── $basename/"
                if [[ $current_depth -lt $max_depth ]]; then
                    list_with_depth "$item" $((current_depth + 1)) $max_depth "${prefix}    "
                fi
            else
                echo "${prefix}├── $basename/"
                if [[ $current_depth -lt $max_depth ]]; then
                    list_with_depth "$item" $((current_depth + 1)) $max_depth "${prefix}│   "
                fi
            fi
        else
            if $is_last; then
                echo "${prefix}└── $basename"
            else
                echo "${prefix}├── $basename"
            fi
        fi
    done
}

# If it's a file, just show the file
if [[ -f "$PATH_ARG" ]]; then
    basename "$PATH_ARG"
    exit 0
fi

# Show the root path
echo "$PATH_ARG"

# List contents
list_with_depth "$PATH_ARG" 1 "$DEPTH" ""
